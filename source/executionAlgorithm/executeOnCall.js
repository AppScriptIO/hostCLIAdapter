"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.executeOnCall = executeOnCall;var _path = _interopRequireDefault(require("path"));
var _assert = _interopRequireDefault(require("assert"));
var _util = _interopRequireDefault(require("util"));
const style = { titleCyan: '\x1b[33m\x1b[1m\x1b[7m\x1b[36m', titleGolden: '\x1b[33m\x1b[1m\x1b[7m', message: '\x1b[96m', italic: '\x1b[2m\x1b[3m', default: '\x1b[0m' };




function executeOnCall({
  scriptPath,
  methodName,
  parameter = [],
  adapterFunction = null })
{
  (0, _assert.default)(_path.default.isAbsolute(scriptPath), `• 'scriptPath' must be an absolute path to be executed.`);
  console.log(`${style.italic}${style.titleGolden}%s${style.default} - %s`, `•[JS module]`, `Running ${scriptPath}`);
  console.log(`\t\x1b[2m\x1b[3m%s\x1b[0m \x1b[95m%s\x1b[0m`, `File path:`, `${scriptPath}`);
  let requiredModule = require(scriptPath);
  let func;

  switch (typeof requiredModule) {
    case 'object':
      (0, _assert.default)(typeof requiredModule[methodName] == 'function', `• "${methodName}" must match property of required module and be a function: ${_util.default.inspect(requiredModule)}`);
      func = requiredModule[methodName];
      break;
    case 'function':
      func = requiredModule;
      break;
    default:
      let partialMessage = methodName ? 'object' : 'function';
      throw new Error(`• Required script ${scriptPath} must be a ${partialMessage}, i.e. the script is expected to export a ${partialMessage}. Required script: ${_util.default.inspect(requiredModule)}`);
      break;}


  if (!Array.isArray(parameter)) parameter = [parameter];

  if (adapterFunction) {
    func = adapterFunction({ callback: func, args: parameter });
    func();
  } else
  func(...parameter);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NvdXJjZS9leGVjdXRpb25BbGdvcml0aG0vZXhlY3V0ZU9uQ2FsbC5qcyJdLCJuYW1lcyI6WyJzdHlsZSIsInRpdGxlQ3lhbiIsInRpdGxlR29sZGVuIiwibWVzc2FnZSIsIml0YWxpYyIsImRlZmF1bHQiLCJleGVjdXRlT25DYWxsIiwic2NyaXB0UGF0aCIsIm1ldGhvZE5hbWUiLCJwYXJhbWV0ZXIiLCJhZGFwdGVyRnVuY3Rpb24iLCJwYXRoIiwiaXNBYnNvbHV0ZSIsImNvbnNvbGUiLCJsb2ciLCJyZXF1aXJlZE1vZHVsZSIsInJlcXVpcmUiLCJmdW5jIiwidXRpbCIsImluc3BlY3QiLCJwYXJ0aWFsTWVzc2FnZSIsIkVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwiY2FsbGJhY2siLCJhcmdzIl0sIm1hcHBpbmdzIjoic01BQUE7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsS0FBSyxHQUFHLEVBQUVDLFNBQVMsRUFBRSxnQ0FBYixFQUErQ0MsV0FBVyxFQUFFLHdCQUE1RCxFQUFzRkMsT0FBTyxFQUFFLFVBQS9GLEVBQTJHQyxNQUFNLEVBQUUsZ0JBQW5ILEVBQXFJQyxPQUFPLEVBQUUsU0FBOUksRUFBZDs7Ozs7QUFLTyxTQUFTQyxhQUFULENBQXVCO0FBQzFCQyxFQUFBQSxVQUQwQjtBQUUxQkMsRUFBQUEsVUFGMEI7QUFHMUJDLEVBQUFBLFNBQVMsR0FBRyxFQUhjO0FBSTFCQyxFQUFBQSxlQUFlLEdBQUcsSUFKUSxFQUF2QjtBQUtKO0FBQ0MsdUJBQU9DLGNBQUtDLFVBQUwsQ0FBZ0JMLFVBQWhCLENBQVAsRUFBcUMseURBQXJDO0FBQ0FNLEVBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFhLEdBQUVkLEtBQUssQ0FBQ0ksTUFBTyxHQUFFSixLQUFLLENBQUNFLFdBQVksS0FBSUYsS0FBSyxDQUFDSyxPQUFRLE9BQWxFLEVBQTJFLGNBQTNFLEVBQTJGLFdBQVVFLFVBQVcsRUFBaEg7QUFDQU0sRUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQWEsNkNBQWIsRUFBNEQsWUFBNUQsRUFBMEUsR0FBRVAsVUFBVyxFQUF2RjtBQUNBLE1BQUlRLGNBQWMsR0FBR0MsT0FBTyxDQUFDVCxVQUFELENBQTVCO0FBQ0EsTUFBSVUsSUFBSjs7QUFFQSxVQUFRLE9BQU9GLGNBQWY7QUFDSSxTQUFLLFFBQUw7QUFDSSwyQkFBTyxPQUFPQSxjQUFjLENBQUNQLFVBQUQsQ0FBckIsSUFBcUMsVUFBNUMsRUFBeUQsTUFBS0EsVUFBVywrREFBOERVLGNBQUtDLE9BQUwsQ0FBYUosY0FBYixDQUE2QixFQUFwSztBQUNBRSxNQUFBQSxJQUFJLEdBQUdGLGNBQWMsQ0FBQ1AsVUFBRCxDQUFyQjtBQUNKO0FBQ0EsU0FBSyxVQUFMO0FBQ0lTLE1BQUFBLElBQUksR0FBR0YsY0FBUDtBQUNKO0FBQ0E7QUFDSSxVQUFJSyxjQUFjLEdBQUtaLFVBQUQsR0FBZSxRQUFmLEdBQTBCLFVBQWhEO0FBQ0EsWUFBTSxJQUFJYSxLQUFKLENBQVcscUJBQW9CZCxVQUFXLGNBQWFhLGNBQWUsNkNBQTRDQSxjQUFlLHNCQUFxQkYsY0FBS0MsT0FBTCxDQUFhSixjQUFiLENBQTZCLEVBQW5MLENBQU47QUFDSixZQVhKOzs7QUFjQSxNQUFHLENBQUNPLEtBQUssQ0FBQ0MsT0FBTixDQUFjZCxTQUFkLENBQUosRUFBOEJBLFNBQVMsR0FBRyxDQUFDQSxTQUFELENBQVo7O0FBRTlCLE1BQUdDLGVBQUgsRUFBb0I7QUFDaEJPLElBQUFBLElBQUksR0FBR1AsZUFBZSxDQUFDLEVBQUVjLFFBQVEsRUFBRVAsSUFBWixFQUFrQlEsSUFBSSxFQUFFaEIsU0FBeEIsRUFBRCxDQUF0QjtBQUNBUSxJQUFBQSxJQUFJO0FBQ1AsR0FIRDtBQUlJQSxFQUFBQSxJQUFJLENBQUMsR0FBR1IsU0FBSixDQUFKO0FBQ1AiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnIFxuaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcbmNvbnN0IHN0eWxlID0geyB0aXRsZUN5YW46ICdcXHgxYlszM21cXHgxYlsxbVxceDFiWzdtXFx4MWJbMzZtJywgdGl0bGVHb2xkZW46ICdcXHgxYlszM21cXHgxYlsxbVxceDFiWzdtJywgbWVzc2FnZTogJ1xceDFiWzk2bScsIGl0YWxpYzogJ1xceDFiWzJtXFx4MWJbM20nLCBkZWZhdWx0OiAnXFx4MWJbMG0nIH1cblxuLyoqXG4gKiBFeGVjdXRlIGBzY3JpcHRDb2ZuaWcudHlwZSA9PSAnbW9kdWxlJ2AgaS5lLiB2YWx1ZSBpcyBleHBvcnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVPbkNhbGwoeyBcbiAgICBzY3JpcHRQYXRoLCBcbiAgICBtZXRob2ROYW1lLCBcbiAgICBwYXJhbWV0ZXIgPSBbXSwgXG4gICAgYWRhcHRlckZ1bmN0aW9uID0gbnVsbCAvLyB0aGUgYWRhcHRlciBtdXN0IHJldHVybiBhIGZ1bmN0aW9uIHdoZXJlIGl0IGVuY2Fwc3VsYXRlcyB0aGUgc3BlY2lmaWMgbmVlZGVkIGltcGxlbWVudGF0aW9uIGZvciB0aGUgc2NyaXB0LlxufSkge1xuICAgIGFzc2VydChwYXRoLmlzQWJzb2x1dGUoc2NyaXB0UGF0aCksIGDigKIgJ3NjcmlwdFBhdGgnIG11c3QgYmUgYW4gYWJzb2x1dGUgcGF0aCB0byBiZSBleGVjdXRlZC5gKVxuICAgIGNvbnNvbGUubG9nKGAke3N0eWxlLml0YWxpY30ke3N0eWxlLnRpdGxlR29sZGVufSVzJHtzdHlsZS5kZWZhdWx0fSAtICVzYCwgYOKAoltKUyBtb2R1bGVdYCwgYFJ1bm5pbmcgJHtzY3JpcHRQYXRofWApXG4gICAgY29uc29sZS5sb2coYFxcdFxceDFiWzJtXFx4MWJbM20lc1xceDFiWzBtIFxceDFiWzk1bSVzXFx4MWJbMG1gLCBgRmlsZSBwYXRoOmAsIGAke3NjcmlwdFBhdGh9YClcbiAgICBsZXQgcmVxdWlyZWRNb2R1bGUgPSByZXF1aXJlKHNjcmlwdFBhdGgpXG4gICAgbGV0IGZ1bmM7IC8vIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcblxuICAgIHN3aXRjaCAodHlwZW9mIHJlcXVpcmVkTW9kdWxlKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHJlcXVpcmVkTW9kdWxlW21ldGhvZE5hbWVdID09ICdmdW5jdGlvbicsIGDigKIgXCIke21ldGhvZE5hbWV9XCIgbXVzdCBtYXRjaCBwcm9wZXJ0eSBvZiByZXF1aXJlZCBtb2R1bGUgYW5kIGJlIGEgZnVuY3Rpb246ICR7dXRpbC5pbnNwZWN0KHJlcXVpcmVkTW9kdWxlKX1gKVxuICAgICAgICAgICAgZnVuYyA9IHJlcXVpcmVkTW9kdWxlW21ldGhvZE5hbWVdXG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6IFxuICAgICAgICAgICAgZnVuYyA9IHJlcXVpcmVkTW9kdWxlXG4gICAgICAgIGJyZWFrOyBcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxldCBwYXJ0aWFsTWVzc2FnZSA9ICAobWV0aG9kTmFtZSkgPyAnb2JqZWN0JyA6ICdmdW5jdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYOKAoiBSZXF1aXJlZCBzY3JpcHQgJHtzY3JpcHRQYXRofSBtdXN0IGJlIGEgJHtwYXJ0aWFsTWVzc2FnZX0sIGkuZS4gdGhlIHNjcmlwdCBpcyBleHBlY3RlZCB0byBleHBvcnQgYSAke3BhcnRpYWxNZXNzYWdlfS4gUmVxdWlyZWQgc2NyaXB0OiAke3V0aWwuaW5zcGVjdChyZXF1aXJlZE1vZHVsZSl9YClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYoIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSkgcGFyYW1ldGVyID0gW3BhcmFtZXRlcl1cblxuICAgIGlmKGFkYXB0ZXJGdW5jdGlvbikge1xuICAgICAgICBmdW5jID0gYWRhcHRlckZ1bmN0aW9uKHsgY2FsbGJhY2s6IGZ1bmMsIGFyZ3M6IHBhcmFtZXRlcn0pXG4gICAgICAgIGZ1bmMoKVxuICAgIH0gZWxzZVxuICAgICAgICBmdW5jKC4uLnBhcmFtZXRlcikgLy8gZXhlY3V0ZSBmdW5jdGlvbiBmcm9tIG1vZHVsZSBwYXNzaW5nIGl0IHRoZSBwYXJhbWV0ZXJzLlxufVxuIl19